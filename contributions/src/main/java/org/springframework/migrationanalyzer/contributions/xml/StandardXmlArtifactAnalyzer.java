/* * Copyright 2010 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.migrationanalyzer.contributions.xml;import java.io.IOException;import java.io.InputStream;import java.util.Map;import javax.xml.namespace.NamespaceContext;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.XPath;import javax.xml.xpath.XPathConstants;import javax.xml.xpath.XPathExpression;import javax.xml.xpath.XPathExpressionException;import javax.xml.xpath.XPathFactory;import org.springframework.migrationanalyzer.analyze.support.AnalysisFailedException;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * The standard implementation of {@link XmlArtifactAnalyzer}. This implementation handles most of the boilerplate code * for dealing with XML files and delegates to specific analyzers for actual work. * <p /> *  * <strong>Concurrent Semantics</strong><br /> *  * Thread-safe */public final class StandardXmlArtifactAnalyzer implements XmlArtifactAnalyzer {    private final Document document;    private final NamespaceContext namespaceContext;    /**     * Creates a new instance, reading the XML content from an {@link InputStream}     *      * @param inputStream The input stream to read from     * @throws AnalysisFailedException     */    public StandardXmlArtifactAnalyzer(InputStream inputStream) throws AnalysisFailedException {        this(inputStream, null, null);    }    /**     * Creates a new instance, reading the XML content from an {@link InputStream}, and using a specified     * {@link EntityResolver}     *      * @param inputStream The input stream to read from     * @param entityResolver The entity resolver to use     * @throws AnalysisFailedException     */    public StandardXmlArtifactAnalyzer(InputStream inputStream, EntityResolver entityResolver) throws AnalysisFailedException {        this(inputStream, null, entityResolver);    }    /**     * Creates a new instance, reading the XML content from an {@link InputStream}, and using specified namespace     * mappings     *      * @param inputStream The input stream to read from     * @param namespaceMappings The namespace mappings to use     * @throws AnalysisFailedException     */    public StandardXmlArtifactAnalyzer(InputStream inputStream, Map<String, String> namespaceMappings) throws AnalysisFailedException {        this(inputStream, namespaceMappings, null);    }    StandardXmlArtifactAnalyzer(InputStream inputStream, Map<String, String> namespaceMapping, EntityResolver entityResolver)        throws AnalysisFailedException {        this.namespaceContext = getNamespaceContext(namespaceMapping);        this.document = getDocument(inputStream, entityResolver);    }    @Override    public void analyzeValues(String expression, ValueAnalyzer analyzer) throws AnalysisFailedException {        this.analyzeValues(this.document, expression, analyzer);    }    @Override    public void analyzeValues(Node rootNode, String expression, ValueAnalyzer analyzer) throws AnalysisFailedException {        NodeList nodes = evaluateXPathExpression(rootNode, expression);        for (int i = 0; i < nodes.getLength(); i++) {            Node node = nodes.item(i);            if (node.getNodeType() == Node.ATTRIBUTE_NODE) {                analyzeRawValue(((Attr) node).getValue(), analyzer);            } else if (node.getNodeType() == Node.ELEMENT_NODE) {                analyzeRawValue(((Element) node).getTextContent(), analyzer);            }        }    }    private NodeList evaluateXPathExpression(Node rootNode, String expression) throws AnalysisFailedException {        try {            return (NodeList) getXPathExpression(expression).evaluate(rootNode, XPathConstants.NODESET);        } catch (XPathExpressionException xpee) {            throw new AnalysisFailedException("Failed to evaluate XPath expression", xpee);        }    }    private void analyzeRawValue(String rawValue, ValueAnalyzer analyzer) throws AnalysisFailedException {        if (rawValue.contains(",")) {            for (String componentValue : rawValue.split(",")) {                analyzer.analyse(componentValue.trim());            }        } else {            analyzer.analyse(rawValue.trim());        }    }    private XPathExpression getXPathExpression(String expressionString) throws XPathExpressionException {        XPathFactory newInstance = XPathFactory.newInstance();        XPath xpath = newInstance.newXPath();        if (this.namespaceContext != null) {            xpath.setNamespaceContext(this.namespaceContext);        }        return xpath.compile(expressionString);    }    private NamespaceContext getNamespaceContext(Map<String, String> namespaceMapping) {        if (namespaceMapping != null) {            return new MapNamespaceContext(namespaceMapping);        }        return null;    }    private boolean isNamespaceAware() {        return this.namespaceContext != null;    }    private Document getDocument(InputStream inputStream, EntityResolver entityResolver) throws AnalysisFailedException {        DocumentBuilderFactory xmlFact = DocumentBuilderFactory.newInstance();        xmlFact.setNamespaceAware(isNamespaceAware());        DocumentBuilder builder;        try {            builder = xmlFact.newDocumentBuilder();            if (entityResolver != null) {                builder.setEntityResolver(entityResolver);            }            return builder.parse(new InputSource(inputStream));        } catch (ParserConfigurationException e) {            throw new AnalysisFailedException(e);        } catch (SAXException e) {            throw new AnalysisFailedException(e);        } catch (IOException e) {            throw new AnalysisFailedException(e);        }    }    @Override    public void analyzeNodes(String expression, NodeAnalyzer analyzer) throws AnalysisFailedException {        this.analyzeNodes(this.document, expression, analyzer);    }    @Override    public void analyzeNodes(Node rootNode, String expression, NodeAnalyzer analyzer) throws AnalysisFailedException {        NodeList nodes = evaluateXPathExpression(rootNode, expression);        for (int i = 0; i < nodes.getLength(); i++) {            Node node = nodes.item(i);            analyzer.analyze(node);        }    }}